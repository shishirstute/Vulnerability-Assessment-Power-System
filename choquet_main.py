from sympy import symbols,solve
from itertools import combinations, chain

def choquet_integral(attributes_values):
    # write your attributes name here
    attributes = ["Net_ability","Entropic_degree","Edge_betweenness"]
    # importance of attributes
    weight_value = [0.45,0.45,0.3]
    # value of attributes
    #attributes_values = [45,50,53]

    def lambda_calculate(attribute_weight_dict):
        # finding lambda value for measure
        lambda_var = symbols('lambda_var')
        expression = 1
        for i in attribute_weight_dict:
            expression = expression * (1 + lambda_var * attribute_weight_dict[i])
        expression = expression - 1 - lambda_var
        # solving polynomial equation
        lambda_value = solve(expression)
        # finding lambda to be used (>-1 but not 0)
        lambda_to_be_used = list(filter(lambda x: x >= -1 and x != 0, lambda_value))
        return lambda_to_be_used

    def sorting_attributes(attributes,attributes_values):
        # arranging attributes in ascending order based on functional value
        order = sorted(zip(attributes, attributes_values), key=lambda x: x[1])
        attribute_order = [order[i][0] for i in range(len(order))]
        return attribute_order

    def measure_combinations(attributes,attribute_weight_dict):
        # this function finds the measurement for all possible combination of attributes

        attributes = list(set(attributes))
        # Generate combinations of all lengths
        all_combinations = list(chain.from_iterable(combinations(attributes, r) for r in range(1, len(attributes) + 1)))

        # finding measure of set # currently working for three attributes.
        g = {}
        for i in range(len(all_combinations)):
            if len(all_combinations[i]) == 1:
                g[(all_combinations[i][0])] = attribute_weight_dict[all_combinations[i][0]]
            elif len(all_combinations[i]) == 2:
                # g[(all_combinations[i][0], all_combinations[i][1])] = attribute_weight_dict[all_combinations[i][0]] +  \
                # attribute_weight_dict[all_combinations[i][1]] + lambda_to_be_used[0]*attribute_weight_dict[all_combinations[i][0]]*attribute_weight_dict[all_combinations[i][1]]
                g[(all_combinations[i][0], all_combinations[i][1])] = g[(all_combinations[i][0])] + g[(all_combinations[i][1])] \
                                                                      + lambda_to_be_used[0] * g[(all_combinations[i][0])] * \
                                                                      g[(all_combinations[i][1])]
            elif len(all_combinations[i]) == 3:
                g[(all_combinations[i][0], all_combinations[i][1], all_combinations[i][2])] = g[(all_combinations[i][0], all_combinations[i][1])] \
                + g[(all_combinations[i][2])] + lambda_to_be_used[0] * g[(all_combinations[i][0], all_combinations[i][1])] * g[(all_combinations[i][2])]

        return g


    def area_order_collection(attribute_order,attributes):
        # Order A[i] i.e. the set where measure is applied see choquet integral formula for better understanding
        A = []
        removed_elements = set()
        for i in range(len(attribute_order)):
            # A.append(tuple(set(attributes) - removed_elements))
            A.append(
                tuple(set(attributes) - removed_elements)[0] if len(tuple(set(attributes) - removed_elements)) == 1 else \
                    tuple(set(attributes) - removed_elements))
            removed_elements.add(attribute_order[i])
        return A

    def choquet_integral_formula(g,attribute_order,attribute_value_dict):
        # finding choquet integraL VALUE
        aggregate_value = 0
        for i in range(len(attribute_order)):
            try:
                measure = g[A[i]]
            except:
                measure = g[A[0][i]]
            if i != 0:
                value_pre = attribute_value_dict[attribute_order[i - 1]]  # f(i-1) value
            else:
                value_pre = 0

            value_cur = attribute_value_dict[attribute_order[i]]  # f(i) value

            aggregate_value += (value_cur - value_pre) * measure

        return aggregate_value

    # creating dictionary for weight and values
    attribute_weight_dict = {attributes[i]:weight_value[i] for i in range(len(attributes))} # attributes:weight pair
    attribute_value_dict = {attributes[i]:attributes_values[i] for i in range(len(attributes))}

    # calling function to calculate lambda to be used
    lambda_to_be_used = lambda_calculate(attribute_weight_dict=attribute_weight_dict)

    # sorting attributes based on ascending order of their functional value
    attribute_order = sorting_attributes(attributes=attributes,attributes_values=attributes_values)

    # calling function to calculate measurement of all combinations of attributes
    g = measure_combinations(attributes=attributes,attribute_weight_dict=attribute_weight_dict)

    # area order collections
    A = area_order_collection(attribute_order = attribute_order,attributes=attributes)

    # calling choquet integral function
    aggregate_value = choquet_integral_formula(g=g,attribute_order=attribute_order,attribute_value_dict=attribute_value_dict)

    print(f"The aggregated value is {aggregate_value}")
    return aggregate_value
